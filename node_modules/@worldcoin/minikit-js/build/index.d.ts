import { AppErrorCodes, IDKitConfig, VerificationLevel } from '@worldcoin/idkit-core';
export { ISuccessResult, AppErrorCodes as VerificationErrorCodes, VerificationLevel } from '@worldcoin/idkit-core';
import { Abi, AbiStateMutability, ExtractAbiFunctionNames, AbiParametersToPrimitiveTypes, ExtractAbiFunction, TypedData, TypedDataDomain } from 'abitype';
export { IVerifyResponse, verifyCloudProof } from '@worldcoin/idkit-core/backend';
import { Client } from 'viem';

declare const VerificationErrorMessage: Record<AppErrorCodes, string>;
declare enum PaymentErrorCodes {
    InputError = "input_error",
    UserRejected = "user_rejected",
    PaymentRejected = "payment_rejected",
    InvalidReceiver = "invalid_receiver",
    InsufficientBalance = "insufficient_balance",
    TransactionFailed = "transaction_failed",
    GenericError = "generic_error",
    UserBlocked = "user_blocked"
}
declare const PaymentErrorMessage: Record<PaymentErrorCodes, string>;
declare enum PaymentValidationErrors {
    MalformedRequest = "There was a problem with this request. Please try again or contact the app owner.",
    InvalidTokenAddress = "The token address is invalid. Please contact the app owner.",
    InvalidAppId = "The app ID is invalid. Please contact the app owner.",
    DuplicateReference = "This reference ID already exists please generate a new one and try again."
}
declare enum WalletAuthErrorCodes {
    MalformedRequest = "malformed_request",
    UserRejected = "user_rejected",
    GenericError = "generic_error"
}
declare const WalletAuthErrorMessage: {
    malformed_request: string;
    user_rejected: string;
    generic_error: string;
};
declare enum SendTransactionErrorCodes {
    InvalidOperation = "invalid_operation",
    UserRejected = "user_rejected",
    InputError = "input_error",
    SimulationFailed = "simulation_failed",
    TransactionFailed = "transaction_failed",
    GenericError = "generic_error",
    DisallowedOperation = "disallowed_operation",
    ValidationError = "validation_error",
    InvalidContract = "invalid_contract",
    MaliciousOperation = "malicious_operation",
    DailyTxLimitReached = "daily_tx_limit_reached",
    PermittedAmountExceedsSlippage = "permitted_amount_exceeds_slippage",
    PermittedAmountNotFound = "permitted_amount_not_found"
}
declare const SendTransactionErrorMessage: Record<SendTransactionErrorCodes, string>;
declare enum SignMessageErrorCodes {
    InvalidMessage = "invalid_message",
    UserRejected = "user_rejected",
    GenericError = "generic_error"
}
declare const SignMessageErrorMessage: {
    invalid_message: string;
    user_rejected: string;
    generic_error: string;
};
declare enum SignTypedDataErrorCodes {
    InvalidOperation = "invalid_operation",
    UserRejected = "user_rejected",
    InputError = "input_error",
    SimulationFailed = "simulation_failed",
    GenericError = "generic_error",
    DisallowedOperation = "disallowed_operation",
    InvalidContract = "invalid_contract",
    MaliciousOperation = "malicious_operation"
}
declare const SignTypedDataErrorMessage: {
    invalid_operation: string;
    user_rejected: string;
    input_error: string;
    simulation_failed: string;
    generic_error: string;
    disallowed_operation: string;
    invalid_contract: string;
    malicious_operation: string;
};
declare enum MiniKitInstallErrorCodes {
    Unknown = "unknown",
    AlreadyInstalled = "already_installed",
    OutsideOfWorldApp = "outside_of_worldapp",
    NotOnClient = "not_on_client",
    AppOutOfDate = "app_out_of_date"
}
declare const MiniKitInstallErrorMessage: {
    unknown: string;
    already_installed: string;
    outside_of_worldapp: string;
    not_on_client: string;
    app_out_of_date: string;
};
declare enum ShareContactsErrorCodes {
    UserRejected = "user_rejected",
    GenericError = "generic_error"
}
declare const ShareContactsErrorMessage: {
    user_rejected: string;
    generic_error: string;
};
declare enum RequestPermissionErrorCodes {
    UserRejected = "user_rejected",
    GenericError = "generic_error",
    AlreadyRequested = "already_requested",
    PermissionDisabled = "permission_disabled",
    AlreadyGranted = "already_granted",
    UnsupportedPermission = "unsupported_permission"
}
declare const RequestPermissionErrorMessage: {
    user_rejected: string;
    generic_error: string;
    already_requested: string;
    permission_disabled: string;
    already_granted: string;
    unsupported_permission: string;
};
declare enum GetPermissionsErrorCodes {
    GenericError = "generic_error"
}
declare const GetPermissionsErrorMessage: {
    generic_error: string;
};
declare enum SendHapticFeedbackErrorCodes {
    GenericError = "generic_error",
    UserRejected = "user_rejected"
}
declare const SendHapticFeedbackErrorMessage: {
    generic_error: string;
    user_rejected: string;
};
declare enum ShareFilesErrorCodes {
    UserRejected = "user_rejected",
    GenericError = "generic_error",
    InvalidFileName = "invalid_file_name"
}
declare const ShareFilesErrorMessage: {
    user_rejected: string;
    generic_error: string;
    invalid_file_name: string;
};
declare enum MicrophoneErrorCodes {
    MiniAppPermissionNotEnabled = "mini_app_permission_not_enabled",
    WorldAppPermissionNotEnabled = "world_app_permission_not_enabled"
}
declare const MicrophoneErrorMessage: {
    mini_app_permission_not_enabled: string;
    world_app_permission_not_enabled: string;
};
declare enum ChatErrorCodes {
    UserRejected = "user_rejected",
    SendFailed = "send_failed",
    GenericError = "generic_error"
}
declare const ChatErrorMessage: {
    user_rejected: string;
    send_failed: string;
    generic_error: string;
};

declare enum Tokens {
    USDC = "USDCE",
    WLD = "WLD"
}
declare const TokenDecimals: {
    [key in Tokens]: number;
};
declare enum Network {
    Optimism = "optimism",
    WorldChain = "worldchain"
}

type Permit2 = {
    permitted: {
        token: string;
        amount: string | unknown;
    };
    spender: string;
    nonce: string | unknown;
    deadline: string | unknown;
};
type Transaction = {
    address: string;
    abi: Abi | readonly unknown[];
    functionName: ContractFunctionName<Abi | readonly unknown[], 'payable' | 'nonpayable'>;
    value?: string | undefined;
    args: ContractFunctionArgs<Abi | readonly unknown[], 'payable' | 'nonpayable', ContractFunctionName<Abi | readonly unknown[], 'payable' | 'nonpayable'>>;
};
type ContractFunctionName<abi extends Abi | readonly unknown[] = Abi, mutability extends AbiStateMutability = AbiStateMutability> = ExtractAbiFunctionNames<abi extends Abi ? abi : Abi, mutability> extends infer functionName extends string ? [functionName] extends [never] ? string : functionName : string;
type ContractFunctionArgs<abi extends Abi | readonly unknown[] = Abi, mutability extends AbiStateMutability = AbiStateMutability, functionName extends ContractFunctionName<abi, mutability> = ContractFunctionName<abi, mutability>> = AbiParametersToPrimitiveTypes<ExtractAbiFunction<abi extends Abi ? abi : Abi, functionName, mutability>['inputs'], 'inputs'> extends infer args ? [args] extends [never] ? readonly unknown[] : args : readonly unknown[];

declare enum Command {
    Verify = "verify",
    Pay = "pay",
    WalletAuth = "wallet-auth",
    SendTransaction = "send-transaction",
    SignMessage = "sign-message",
    SignTypedData = "sign-typed-data",
    ShareContacts = "share-contacts",
    RequestPermission = "request-permission",
    GetPermissions = "get-permissions",
    SendHapticFeedback = "send-haptic-feedback",
    Share = "share",
    Chat = "chat"
}
type WebViewBasePayload = {
    command: Command;
    version: number;
    payload: Record<string, any>;
};
type AsyncHandlerReturn<CommandPayload, FinalPayload> = Promise<{
    commandPayload: CommandPayload;
    finalPayload: FinalPayload;
}>;
type VerifyCommandInput = {
    action: IDKitConfig['action'];
    signal?: IDKitConfig['signal'];
    verification_level?: VerificationLevel;
};
type VerifyCommandPayload = VerifyCommandInput & {
    timestamp: string;
};
type TokensPayload = {
    symbol: Tokens;
    token_amount: string;
};
type PayCommandInput = {
    reference: string;
    to: `0x${string}` | string;
    tokens: TokensPayload[];
    network?: Network;
    description: string;
};
type PayCommandPayload = PayCommandInput;
type WalletAuthInput = {
    nonce: string;
    statement?: string;
    requestId?: string;
    expirationTime?: Date;
    notBefore?: Date;
};
type WalletAuthPayload = {
    siweMessage: string;
};
type MiniKitInstallReturnType = {
    success: true;
} | {
    success: false;
    errorCode: MiniKitInstallErrorCodes;
    errorMessage: (typeof MiniKitInstallErrorMessage)[MiniKitInstallErrorCodes];
};
type SendTransactionInput = {
    transaction: Transaction[];
    permit2?: Permit2[];
    formatPayload?: boolean;
};
type SendTransactionPayload = SendTransactionInput;
type SignMessageInput = {
    message: string;
};
type SignMessagePayload = SignMessageInput;
type SignTypedDataInput = {
    types: TypedData;
    primaryType: string;
    message: Record<string, unknown>;
    domain?: TypedDataDomain;
    chainId?: number;
};
type SignTypedDataPayload = SignTypedDataInput;
type ShareContactsInput = {
    isMultiSelectEnabled: boolean;
    inviteMessage?: string;
};
type ShareContactsPayload = ShareContactsInput;
declare enum Permission {
    Notifications = "notifications",
    Contacts = "contacts",
    Microphone = "microphone"
}
type RequestPermissionInput = {
    permission: Permission;
};
type RequestPermissionPayload = RequestPermissionInput;
type GetPermissionsInput = {};
type GetPermissionsPayload = GetPermissionsInput;
type SendHapticFeedbackInput = {
    hapticsType: 'notification';
    style: 'error' | 'success' | 'warning';
} | {
    hapticsType: 'selection-changed';
    style?: never;
} | {
    hapticsType: 'impact';
    style: 'light' | 'medium' | 'heavy';
};
type SendHapticFeedbackPayload = SendHapticFeedbackInput;
type ShareInput = {
    files?: File[];
    title?: string;
    text?: string;
    url?: string;
};
type SharePayload = {
    files?: Array<{
        name: string;
        type: string;
        data: string;
    }>;
    title?: string;
    text?: string;
    url?: string;
};
type ChatPayload = {
    to?: string[];
    message: string;
};
type CommandReturnPayloadMap = {
    [Command.Verify]: VerifyCommandPayload;
    [Command.Pay]: PayCommandPayload;
    [Command.WalletAuth]: WalletAuthPayload;
    [Command.SendTransaction]: SendTransactionPayload;
    [Command.SignMessage]: SignMessagePayload;
    [Command.SignTypedData]: SignTypedDataPayload;
    [Command.ShareContacts]: ShareContactsPayload;
    [Command.RequestPermission]: RequestPermissionPayload;
    [Command.GetPermissions]: GetPermissionsPayload;
    [Command.SendHapticFeedback]: SendHapticFeedbackPayload;
    [Command.Share]: SharePayload;
    [Command.Chat]: ChatPayload;
};
type CommandReturnPayload<T extends Command> = T extends keyof CommandReturnPayloadMap ? CommandReturnPayloadMap[T] : never;

type User = {
    walletAddress?: string;
    username?: string;
    profilePictureUrl?: string;
    permissions?: {
        notifications: boolean;
        contacts: boolean;
    };
    optedIntoOptionalAnalytics?: boolean;
    /** @deprecated Moved to DeviceProperties */
    worldAppVersion?: number;
    /** @deprecated Moved to DeviceProperties */
    deviceOS?: string;
};
type DeviceProperties = {
    safeAreaInsets?: {
        top: number;
        right: number;
        bottom: number;
        left: number;
    };
    deviceOS?: string;
    worldAppVersion?: number;
};
type UserNameService = {
    walletAddress: string;
    username?: string;
    profilePictureUrl?: string;
};
type MiniAppLocation = {
    countryCode?: string;
    regionCode?: string;
};
declare enum MiniAppLaunchLocation {
    Chat = "chat",
    Home = "home",
    AppStore = "app-store",
    DeepLink = "deep-link",
    WalletTab = "wallet-tab"
}
declare const mapWorldAppLaunchLocation: (location: string | null | undefined) => MiniAppLaunchLocation | null;

declare enum ResponseEvent {
    MiniAppVerifyAction = "miniapp-verify-action",
    MiniAppPayment = "miniapp-payment",
    MiniAppWalletAuth = "miniapp-wallet-auth",
    MiniAppSendTransaction = "miniapp-send-transaction",
    MiniAppSignMessage = "miniapp-sign-message",
    MiniAppSignTypedData = "miniapp-sign-typed-data",
    MiniAppShareContacts = "miniapp-share-contacts",
    MiniAppRequestPermission = "miniapp-request-permission",
    MiniAppGetPermissions = "miniapp-get-permissions",
    MiniAppSendHapticFeedback = "miniapp-send-haptic-feedback",
    MiniAppShare = "miniapp-share",
    MiniAppMicrophone = "miniapp-microphone",
    MiniAppChat = "miniapp-chat"
}
type MiniAppVerifyActionSuccessPayload = {
    status: 'success';
    proof: string;
    merkle_root: string;
    nullifier_hash: string;
    verification_level: VerificationLevel;
    version: number;
};
type MiniAppVerifyActionErrorPayload = {
    status: 'error';
    error_code: AppErrorCodes;
    version: number;
};
type MiniAppVerifyActionPayload = MiniAppVerifyActionSuccessPayload | MiniAppVerifyActionErrorPayload;
type MiniAppPaymentSuccessPayload = {
    status: 'success';
    transaction_status: 'submitted';
    transaction_id: string;
    reference: string;
    from: string;
    chain: Network;
    timestamp: string;
    version: number;
};
type MiniAppPaymentErrorPayload = {
    status: 'error';
    error_code: PaymentErrorCodes;
    version: number;
};
type MiniAppPaymentPayload = MiniAppPaymentSuccessPayload | MiniAppPaymentErrorPayload;
type MiniAppWalletAuthSuccessPayload = {
    status: 'success';
    message: string;
    signature: string;
    address: string;
    version: number;
};
type MiniAppWalletAuthErrorPayload = {
    status: 'error';
    error_code: WalletAuthErrorCodes;
    details: (typeof WalletAuthErrorMessage)[WalletAuthErrorCodes];
    version: number;
};
type MiniAppWalletAuthPayload = MiniAppWalletAuthSuccessPayload | MiniAppWalletAuthErrorPayload;
type MiniAppSendTransactionSuccessPayload = {
    status: 'success';
    transaction_status: 'submitted';
    transaction_id: string;
    reference: string;
    from: string;
    chain: Network;
    timestamp: string;
    version: number;
    mini_app_id?: string;
};
type MiniAppSendTransactionErrorPayload = {
    status: 'error';
    error_code: SendTransactionErrorCodes;
    details?: Record<string, any>;
    version: number;
    mini_app_id?: string;
};
type MiniAppSendTransactionPayload = MiniAppSendTransactionSuccessPayload | MiniAppSendTransactionErrorPayload;
type MiniAppSignMessageSuccessPayload = {
    status: 'success';
    signature: string;
    address: string;
    version: number;
};
type MiniAppSignMessageErrorPayload = {
    status: 'error';
    error_code: SignMessageErrorCodes;
    details?: Record<string, any>;
    version: number;
};
type MiniAppSignMessagePayload = MiniAppSignMessageSuccessPayload | MiniAppSignMessageErrorPayload;
type MiniAppSignTypedDataSuccessPayload = {
    status: 'success';
    signature: string;
    address: string;
    version: number;
};
type MiniAppSignTypedDataErrorPayload = {
    status: 'error';
    error_code: SignTypedDataErrorCodes;
    details?: Record<string, any>;
    version: number;
};
type MiniAppSignTypedDataPayload = MiniAppSignTypedDataSuccessPayload | MiniAppSignTypedDataErrorPayload;
type Contact = {
    username: string;
    walletAddress: string;
    profilePictureUrl: string | null;
};
type MiniAppShareContactsSuccessPayload = {
    status: 'success';
    contacts: Contact[];
    version: number;
    timestamp: string;
};
type MiniAppShareContactsErrorPayload = {
    status: 'error';
    error_code: ShareContactsErrorCodes;
    version: number;
};
type MiniAppShareContactsPayload = MiniAppShareContactsSuccessPayload | MiniAppShareContactsErrorPayload;
type MiniAppRequestPermissionSuccessPayload = {
    status: 'success';
    permission: Permission;
    timestamp: string;
    version: number;
};
type MiniAppRequestPermissionErrorPayload = {
    status: 'error';
    error_code: RequestPermissionErrorCodes;
    description: string;
    version: number;
};
type MiniAppRequestPermissionPayload = MiniAppRequestPermissionSuccessPayload | MiniAppRequestPermissionErrorPayload;
type PermissionSettings = {
    [K in Permission]?: any;
};
type MiniAppGetPermissionsSuccessPayload = {
    status: 'success';
    permissions: PermissionSettings;
    version: number;
    timestamp: string;
};
type MiniAppGetPermissionsErrorPayload = {
    status: 'error';
    error_code: GetPermissionsErrorCodes;
    details: string;
    version: number;
};
type MiniAppGetPermissionsPayload = MiniAppGetPermissionsSuccessPayload | MiniAppGetPermissionsErrorPayload;
type MiniAppSendHapticFeedbackSuccessPayload = {
    status: 'success';
    version: number;
    timestamp: string;
};
type MiniAppSendHapticFeedbackErrorPayload = {
    status: 'error';
    error_code: SendHapticFeedbackErrorCodes;
    version: number;
};
type MiniAppSendHapticFeedbackPayload = MiniAppSendHapticFeedbackSuccessPayload | MiniAppSendHapticFeedbackErrorPayload;
type MiniAppShareSuccessPayload = {
    status: 'success';
    shared_files_count: number;
    version: number;
    timestamp: string;
};
type MiniAppShareErrorPayload = {
    status: 'error';
    error_code: ShareFilesErrorCodes;
    version: number;
};
type MiniAppSharePayload = MiniAppShareSuccessPayload | MiniAppShareErrorPayload;
type MiniAppMicrophoneSuccessPayload = {
    status: 'success';
    version: number;
    timestamp: string;
};
type MiniAppMicrophoneErrorPayload = {
    status: 'error';
    error_code: MicrophoneErrorCodes;
    version: number;
};
type MiniAppMicrophonePayload = MiniAppMicrophoneSuccessPayload | MiniAppMicrophoneErrorPayload;
type MiniAppChatSuccessPayload = {
    status: 'success';
    count: number;
    timestamp: string;
    version: number;
};
type MiniAppChatErrorPayload = {
    status: 'error';
    error_code: ChatErrorCodes;
    version: number;
};
type MiniAppChatPayload = MiniAppChatSuccessPayload | MiniAppChatErrorPayload;
type EventPayloadMap = {
    [ResponseEvent.MiniAppVerifyAction]: MiniAppVerifyActionPayload;
    [ResponseEvent.MiniAppPayment]: MiniAppPaymentPayload;
    [ResponseEvent.MiniAppWalletAuth]: MiniAppWalletAuthPayload;
    [ResponseEvent.MiniAppSendTransaction]: MiniAppSendTransactionPayload;
    [ResponseEvent.MiniAppSignMessage]: MiniAppSignMessagePayload;
    [ResponseEvent.MiniAppSignTypedData]: MiniAppSignTypedDataPayload;
    [ResponseEvent.MiniAppShareContacts]: MiniAppShareContactsPayload;
    [ResponseEvent.MiniAppRequestPermission]: MiniAppRequestPermissionPayload;
    [ResponseEvent.MiniAppGetPermissions]: MiniAppGetPermissionsPayload;
    [ResponseEvent.MiniAppSendHapticFeedback]: MiniAppSendHapticFeedbackPayload;
    [ResponseEvent.MiniAppShare]: MiniAppSharePayload;
    [ResponseEvent.MiniAppMicrophone]: MiniAppMicrophonePayload;
    [ResponseEvent.MiniAppChat]: MiniAppChatPayload;
};
type EventPayload<T extends ResponseEvent = ResponseEvent> = T extends keyof EventPayloadMap ? EventPayloadMap[T] : never;
type EventHandler<E extends ResponseEvent = ResponseEvent> = <T extends EventPayload<E>>(data: T) => void;

declare class MiniKit {
    private static readonly MINIKIT_VERSION;
    private static readonly MINIKIT_MINOR_VERSION;
    private static readonly miniKitCommandVersion;
    private static isCommandAvailable;
    private static listeners;
    static appId: string | null;
    static user: User;
    static deviceProperties: DeviceProperties;
    static location: MiniAppLaunchLocation | null;
    private static isReady;
    private static sendInit;
    static subscribe<E extends ResponseEvent>(event: E, handler: EventHandler<E>): void;
    static unsubscribe(event: ResponseEvent): void;
    static trigger(event: ResponseEvent, payload: EventPayload): void;
    private static awaitCommand;
    private static commandsValid;
    static install(appId?: string): MiniKitInstallReturnType;
    static isInstalled(debug?: boolean): boolean;
    static getUserByAddress: (address?: string) => Promise<UserNameService>;
    static getUserByUsername: (username: string) => Promise<UserNameService>;
    static getMiniAppUrl: (appId: string, path?: string) => string;
    static showProfileCard: (username?: string, walletAddress?: string) => void;
    static getUserInfo: (address?: string) => Promise<UserNameService>;
    static commands: {
        verify: (payload: VerifyCommandInput) => VerifyCommandPayload | null;
        pay: (payload: PayCommandInput) => PayCommandPayload | null;
        walletAuth: (payload: WalletAuthInput) => WalletAuthPayload | null;
        sendTransaction: (payload: SendTransactionInput) => SendTransactionPayload | null;
        signMessage: (payload: SignMessageInput) => SignMessagePayload | null;
        signTypedData: (payload: SignTypedDataInput) => SignTypedDataPayload | null;
        shareContacts: (payload: ShareContactsPayload) => ShareContactsPayload | null;
        requestPermission: (payload: RequestPermissionInput) => RequestPermissionPayload | null;
        getPermissions: () => GetPermissionsPayload | null;
        sendHapticFeedback: (payload: SendHapticFeedbackInput) => SendHapticFeedbackPayload | null;
        share: (payload: ShareInput) => ShareInput | null;
        chat: (payload: ChatPayload) => ChatPayload | null;
    };
    /**
     * This object contains async versions of all the commands.
     * Instead of using event listeners, you can just `await` these.
     *
     * They return a standardized object
     *
     * commandPayload - object returned by the command function
     *
     * finalPayload - object returned by the event listener, or in other words, WorldApp response
     */
    static commandsAsync: {
        verify: (payload: VerifyCommandInput) => AsyncHandlerReturn<VerifyCommandPayload | null, MiniAppVerifyActionPayload>;
        pay: (payload: PayCommandInput) => AsyncHandlerReturn<PayCommandPayload | null, MiniAppPaymentPayload>;
        walletAuth: (payload: WalletAuthInput) => AsyncHandlerReturn<WalletAuthPayload | null, MiniAppWalletAuthPayload>;
        sendTransaction: (payload: SendTransactionInput) => AsyncHandlerReturn<SendTransactionPayload | null, MiniAppSendTransactionPayload>;
        signMessage: (payload: SignMessageInput) => AsyncHandlerReturn<SignMessagePayload | null, MiniAppSignMessagePayload>;
        signTypedData: (payload: SignTypedDataInput) => AsyncHandlerReturn<SignTypedDataPayload | null, MiniAppSignTypedDataPayload>;
        shareContacts: (payload: ShareContactsPayload) => AsyncHandlerReturn<ShareContactsPayload | null, MiniAppShareContactsPayload>;
        requestPermission: (payload: RequestPermissionInput) => AsyncHandlerReturn<RequestPermissionPayload | null, MiniAppRequestPermissionPayload>;
        getPermissions: () => AsyncHandlerReturn<GetPermissionsPayload | null, MiniAppGetPermissionsPayload>;
        sendHapticFeedback: (payload: SendHapticFeedbackInput) => AsyncHandlerReturn<SendHapticFeedbackPayload | null, MiniAppSendHapticFeedbackPayload>;
        share: (payload: ShareInput) => AsyncHandlerReturn<ShareInput | null, MiniAppSharePayload>;
        chat: (payload: ChatPayload) => AsyncHandlerReturn<ChatPayload | null, MiniAppChatPayload>;
    };
}

type SiweMessage = {
    scheme?: string;
    domain: string;
    address?: string;
    statement?: string;
    uri: string;
    version: string;
    chain_id: number;
    nonce: string;
    issued_at: string;
    expiration_time?: string;
    not_before?: string;
    request_id?: string;
};

declare const tokenToDecimals: (amount: number, token: Tokens) => number;

declare const parseSiweMessage: (inputString: string) => SiweMessage;
declare const verifySiweMessage: (payload: MiniAppWalletAuthSuccessPayload, nonce: string, statement?: string, requestId?: string, userProvider?: Client) => Promise<{
    isValid: boolean;
    siweMessageData: SiweMessage;
}>;

declare const getIsUserVerified: (walletAddress: string, rpcUrl?: string) => Promise<boolean>;

export { type AsyncHandlerReturn, ChatErrorCodes, ChatErrorMessage, type ChatPayload, Command, type CommandReturnPayload, type Contact, type DeviceProperties, type EventHandler, type EventPayload, GetPermissionsErrorCodes, GetPermissionsErrorMessage, type GetPermissionsInput, type GetPermissionsPayload, MicrophoneErrorCodes, MicrophoneErrorMessage, type MiniAppChatErrorPayload, type MiniAppChatPayload, type MiniAppChatSuccessPayload, type MiniAppGetPermissionsErrorPayload, type MiniAppGetPermissionsPayload, type MiniAppGetPermissionsSuccessPayload, MiniAppLaunchLocation, type MiniAppLocation, type MiniAppMicrophoneErrorPayload, type MiniAppMicrophonePayload, type MiniAppMicrophoneSuccessPayload, type MiniAppPaymentErrorPayload, type MiniAppPaymentPayload, type MiniAppPaymentSuccessPayload, type MiniAppRequestPermissionErrorPayload, type MiniAppRequestPermissionPayload, type MiniAppRequestPermissionSuccessPayload, type MiniAppSendHapticFeedbackErrorPayload, type MiniAppSendHapticFeedbackPayload, type MiniAppSendHapticFeedbackSuccessPayload, type MiniAppSendTransactionErrorPayload, type MiniAppSendTransactionPayload, type MiniAppSendTransactionSuccessPayload, type MiniAppShareContactsErrorPayload, type MiniAppShareContactsPayload, type MiniAppShareContactsSuccessPayload, type MiniAppShareErrorPayload, type MiniAppSharePayload, type MiniAppShareSuccessPayload, type MiniAppSignMessageErrorPayload, type MiniAppSignMessagePayload, type MiniAppSignMessageSuccessPayload, type MiniAppSignTypedDataErrorPayload, type MiniAppSignTypedDataPayload, type MiniAppSignTypedDataSuccessPayload, type MiniAppVerifyActionErrorPayload, type MiniAppVerifyActionPayload, type MiniAppVerifyActionSuccessPayload, type MiniAppWalletAuthErrorPayload, type MiniAppWalletAuthPayload, type MiniAppWalletAuthSuccessPayload, MiniKit, MiniKitInstallErrorCodes, MiniKitInstallErrorMessage, type MiniKitInstallReturnType, Network, type PayCommandInput, type PayCommandPayload, PaymentErrorCodes, PaymentErrorMessage, PaymentValidationErrors, Permission, type PermissionSettings, RequestPermissionErrorCodes, RequestPermissionErrorMessage, type RequestPermissionInput, type RequestPermissionPayload, ResponseEvent, SendHapticFeedbackErrorCodes, SendHapticFeedbackErrorMessage, type SendHapticFeedbackInput, type SendHapticFeedbackPayload, SendTransactionErrorCodes, SendTransactionErrorMessage, type SendTransactionInput, type SendTransactionPayload, ShareContactsErrorCodes, ShareContactsErrorMessage, type ShareContactsInput, type ShareContactsPayload, ShareFilesErrorCodes, ShareFilesErrorMessage, type ShareInput, type SharePayload, SignMessageErrorCodes, SignMessageErrorMessage, type SignMessageInput, type SignMessagePayload, SignTypedDataErrorCodes, SignTypedDataErrorMessage, type SignTypedDataInput, type SignTypedDataPayload, type SiweMessage, TokenDecimals, Tokens, type TokensPayload, type User, type UserNameService, VerificationErrorMessage, type VerifyCommandInput, type VerifyCommandPayload, WalletAuthErrorCodes, WalletAuthErrorMessage, type WalletAuthInput, type WalletAuthPayload, type WebViewBasePayload, getIsUserVerified, mapWorldAppLaunchLocation, parseSiweMessage, tokenToDecimals, verifySiweMessage };
